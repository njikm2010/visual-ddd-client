# DSL 比对算法以及标记形式

- 我们会将比对结果标记在 DSL 上，代码生成器根据 DSL + 标记 增量生成最终的代码。
- 标记只是代码生成器的'辅助信息'。可以用于指示代码的变更操作，比如**移除**和**重命名**。因为单纯从一个 DSL 副本中无法得出这些信息
- 为了更好的容错性，生成器仍然需要完整地遍历 DSL，而不是仅仅根据标记进行操作。因为代码和 DSL 之间可能会有不一致。

## 基本概念

- 原子值：即没有下级对象或者关联关系的值，如字符串、数字、布尔值、字符串数组等, 这些值可以直接进行值比较
- 对象：对象是主要的比对单位, 每个对象都有唯一的 id(uuid)

## 标记方式

```ts
{
  // 对象属性
  __delta: Delta;
}
```

扩展一个 `__delta` 属性，用于标记对象的变更情况

## Delta 对象:

```ts
{
  // new 该对象被标记为新增对象
  // delete 该对象被标记为删除
  // move 每个对象都有唯一的 id, 该对象的上下级关系发生了变更, 生成器可以从旧的 DSL 中查找就得上下文，然后进行移动操作
  // dirty 该对象已经脏，即本身或者子节点发生了变更, 对于需要性能优化的场景，可以通过这个属性来判断是否需要继续往下遍历
  // 这里可能是位操作，不排除后续还有其他状态的接入，或者并行的状态
  op: 'new' | 'delete' | 'move' | 'dirty' | 'update';

  // 当前组件的一些变更操作
  deltas: Array<
    | {
        type: 'update';
        key: string;
        oldValue: any;
      }
    | {
        type: 'new';
        key: string;
      }
    | {
        type: 'delete';
        key: string;
        value: 2;
      }
    | {
        type: 'dirty';
        key: string;
      }
  >;
}
```

对比两个对象：

如果没有 key，则是标记自身

| A                 | B                 | delta                                 | 对象标记  | 备注                                                                                     |
| ----------------- | ----------------- | ------------------------------------- | --------- | ---------------------------------------------------------------------------------------- |
| {a: 1}            | undefined         |                                       | new       | 全新的对象                                                                               |
| undefined         | {a: 1}            |                                       | delete    | 对象被删除                                                                               |
| {a: 1}            | {a: 2}            | {type: 'update', key: a, oldValue: 2} | dirty     | 属性变更                                                                                 |
| {a: 1, b: 2}      | {a: 1}            | {type: 'new', key: b }                | dirty     | 属性新增                                                                                 |
| {a: 1 }           | {a: 1, b: 2}      | {type: 'delete', key: b, value: 2}    | dirty     | 属性删除                                                                                 |
| {a: {a: 1}}       | {a: {b: 1}}       | {type: 'dirty', key: a },             | dirty     | 引用属性变更                                                                             |
| A -> {a: 1, b: 2} | B -> {a: 1, b: 3} |                                       | move, new | 对象移动, 作为一个全新的对象处理，生成器可以从其他地方移动代码文件，在此的基础上进行生成 |

---

对比两个引用数组:

- 因为每个对象都有唯一 id, 我们可以简单地计算出新增和删除
- 顺序会按照新的 DSL 进行排序
- 被移除的对象会放在队列尾部
- 对于新增的对象，可能会在堂兄弟之间查找，识别出移动操作

举个例子:

```
New: [A, B, C]
Old: [B, C, D]

NewBrother: [E, F, G]
OldBrother: [A, E, F]
```

```
New
[
	A with delta {op: move},
	B,
	C,
	D with delta {op: delete},
]
```

```
NewBrother
[
	E,
	F,
	G with delta {op: new},
	A with delta {op: delete},
]
```
